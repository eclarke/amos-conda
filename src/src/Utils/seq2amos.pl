#!/usr/bin/perl -w

use strict;

use AMOS::AmosFoundation;
use AMOS::AmosLib;
use AMOS::ParseFasta;


my $base = new AMOS::AmosFoundation();    
die("ERROR: problems creating an AMOS::Foundation object\n") unless($base);

my $VERSION = '$Revision$ ';

###############################

my $HELP = q~
    seq2amos [options]
	 
    OPTIONS:
    	-n <s>	 		: library name  (default: unmated) (Example: solexap,solexa,454p,454)
	                          if library nameis 454p, the program tries to identify and delete linker sequence
				  
	-i <n>			: library id    (default: 1)
	-m <f>	 		: library mean  (default: 0)
	-s <f>	 		: library stdev (default: 0)

	-fs <s> 		: Sequence file (forward)
	-rs <s> 		: Sequence file (reverse): if given the program assumes mated reads 
	
	-fq <s> 		: Quality file (forward)
	-rq <s> 		: Quality file (reverse): if given the program assumes mated reads 
	
	-sf <s>			: forward seq name suffix (default: a)
        -sr <s> 	        : reverse seq name suffix (default: b)

	-b <n> 			: min id (default:1)
		 
    EXAMPLE:
    
    	####################################################################################
    	# Solexa
	
	# mated reads
	$ seq2amos.pl -n solexap -m 100 -s 20 -fs solexa_f.fasta  -rs solexa_f.fasta  > solexap.afg
	$ seq2amos.pl -n solexap -m 100 -s 20 -fs solexa_f*.fasta -rs solexa_r*.fasta > solexap.afg	
	
	# unmated reads
	$ seq2amos.pl -n solexa               -fs solexa.fasta                        > solexa.afg	
	
	####################################################################################
    	# 454	
	
	# mated reads
	$ seq2amos.pl -n 454p    -m 3000 -s 300 -fs 454.seq                           > 454p.afg
	
	# unmated reads
	$ seq2amos.pl -n 454                    -fs 454.seq                           > 454.afg

	####################################################################################
~;

###############################################################################
#             
# Main program       
#
###############################################################################

MAIN:         
{
	$base->setVersion($VERSION);
	$base->setHelpText($HELP);

	my $minSeqId=1;	
	my $minSeqLen=0;
	my $defaultQual='D';	
		
	my %files;
	my %suffix;
	($suffix{fwd},$suffix{rev})=("a","b");
	
	my %fh;
	
	my %lib;
	($lib{name},$lib{id},$lib{mean},$lib{stdev})=("unknown",$minSeqId++,0,0);	
		
	my @f;
	
	###########################
		
	my $result = $base->getOptions(			
		"fs=s"		=>	\$files{fwd}{seq},
		"rs=s"		=>	\$files{rev}{seq},
		
                "fq=s"          =>      \$files{fwd}{qual},
                "rq=s"          =>      \$files{rev}{qual},

		"sf=s"		=>	\$suffix{fwd},
		"sr=s"          =>      \$suffix{rev},

		"libName|n=s"	=>	\$lib{name},		
		"libId|i=i"	=>	\$lib{id},		
		"libMean|m=f"	=>	\$lib{mean},
		"libStdev|s=f"	=>	\$lib{stdev},		
		
		"minSeqId=i"	=>	\$minSeqId,
		"minSeqLen=i"	=>	\$minSeqLen
	);
	
	######################
	
	defined($files{fwd}{seq}) or $base->bail("Forward sequence file name(s) expected as argument(s)\n");
		
	foreach my $dir ('fwd','rev')
	{
		foreach my $type ('seq','qual')
		{
			next unless($files{$dir}{$type});
			
			my $fh;
			open($fh, "/bin/cat $files{$dir}{$type} | " ) || $base->bail("Cannot open $files{$dir}{$type}: $!\n");	
        		$fh{$dir}{$type} = new AMOS::ParseFasta(\*$fh);
        		$fh{$dir}{$type} or $base->bail("Fasta format expected in $files{$dir}{$type}: $!\n");
		}
	}
	
	######################	
		
	$lib{mean}=$lib{name}{mean}    if(!defined($lib{mean})  and defined($lib{name}{mean}));
	$lib{stdev}=$lib{name}{stdev}  if(!defined($lib{stdev}) and defined($lib{name}{stdev}));
		
	##########################
	
	printMsg("{UNV","eid:afg","com:","generated by $0",`date`.".","}"); 
	printMsg("{LIB","iid:$lib{id}","eid:$lib{name}","{DST","mea:$lib{mean}","std:$lib{stdev}","}","}");  
	
	######################
	
    	while (1)
    	{       
		my %frg;
		$frg{id}=$minSeqId++;	
				
	        foreach my $dir ('fwd','rev')
        	{
			next unless($files{$dir}{seq});

			($frg{$dir}{head}, $frg{$dir}{seq}) = $fh{$dir}{seq}->getRecord();

			if(!defined($frg{$dir}{head}))
			{
				if($dir eq 'fwd')  { exit 0; }
				else 		   { $base->bail("premature end of the reverse sequence file\n"); }
			}
			
			$frg{$dir}{head} =~ /^(\S+)/ or $base->bail("$frg{$dir}{head} : sequence name format error\n");
			$frg{$dir}{name} = $1;
                	$frg{$dir}{len}=length($frg{$dir}{seq});
                	$frg{$dir}{qual}=$defaultQual x $frg{$dir}{len};

	                $frg{$dir}{id}=$minSeqId++;
		}


                foreach my $dir ('fwd','rev')
                {
                        next unless($files{$dir}{qual});

                        my ($head,$qual) = $fh{$dir}{qual}->getRecord();
			if(!defined($head)) { $base->bail("premature end of the $dir quality file\n"); }

                        $head =~ /^(\S+)/ or $base->bail("$head : quality name format error\n");
                        my $name = $1;
			$name eq $frg{$dir}{name} or $base->bail("$name : sequence and quality names do not match\n");
                        
			my @qual=split / /,$qual;
			my $len=@qual;
			$len eq $frg{$dir}{len} or $base->bail("$name : sequence and quality lengths do not match\n");
		
			$frg{$dir}{qual}="";
			foreach my $q (@qual) { $frg{$dir}{qual}.=chr(ord('0')+$q); }
		}

		####################

		if(!$frg{rev}{seq} and $lib{name} eq "454p")
		{
	        	($frg{fwd}{seq},$frg{rev}{seq})=removeLinker($frg{fwd}{seq});
                	next unless($frg{fwd}{seq});

	                $frg{fwd}{len}=length($frg{fwd}{seq});
               
			if($frg{rev}{seq})
                	{
				$frg{rev}{name}=$frg{fwd}{name};

                        	$frg{rev}{id}=$minSeqId++;
                        	$frg{rev}{len}=length($frg{rev}{seq});
                        	$frg{rev}{qual}=substr($frg{fwd}{qual},-$frg{rev}{len});
			}

			$frg{fwd}{qual}=reverse(substr($frg{fwd}{qual},0,$frg{fwd}{len}));
		}
        				
		#############################

		if($frg{rev}{seq})
                {
			$frg{fwd}{name}.=$suffix{fwd};
			$frg{rev}{name}.=$suffix{rev};
				
			printMsg("{FRG","iid:$frg{id}","eid:$frg{id}","lib:$lib{id}","typ:I","rds:$frg{fwd}{id},$frg{rev}{id}","}");
		}
		else
		{
			printMsg("{FRG","iid:$frg{id}","eid:$frg{id}","lib:$lib{id}","typ:I","}");
		}
		
		printMsg("{RED","iid:$frg{fwd}{id}","eid:$frg{fwd}{name}","seq:",$frg{fwd}{seq},".","qlt:",$frg{fwd}{qual},".","frg:$frg{id}","clr:0,$frg{fwd}{len}","}");
		
		if($frg{rev}{seq}) 
		{
			printMsg("{RED","iid:$frg{rev}{id}","eid:$frg{rev}{name}","seq:",$frg{rev}{seq},".","qlt:",$frg{rev}{qual},".","frg:$frg{id}","clr:0,$frg{rev}{len}","}");
		}

		next;
    	}
	
	exit 0;
}

#############################################################################################

sub printMsg
{
	print join "\n",@_;
	print "\n";
}

sub removeLinker
{
        my $seq=shift;
        my $seq2=revComp($seq);
        my $seqLen=length($seq);

        my $linkerLen=44;
        my %lmers=(
                0       =>      "GTTGGAACCGAA",
                4       =>      "GAACCGAAAGGG",
                8       =>      "CGAAAGGGTTTG",
                12      =>      "AGGGTTTGAATT",
                16      =>      "TTTGAATTCAAA",
                20      =>      "AATTCAAACCCT",
                24      =>      "CAAACCCTTTCG",
                28      =>      "CCCTTTCGGTTC",
                32      =>      "TTCGGTTCCAAC");

        my $lmerLen=12;
        my $lmerDistance=4;

        my ($left,$right);
        my ($leftOffset,$rightOffset);
        my ($fwdSeq,$revSeq,$linkerSeq)=("","");

        ###
        my $offset=0;
        while($offset<$linkerLen-$lmerLen) 
        { 
                if($seq=~/^(.+?)$lmers{$offset}/i)
                {
                        ($left,$leftOffset)=(length($1),$offset) if(!defined($left) or $left>length($1)) ;
                }
                elsif($seq=~/^$lmers{$offset}/i)
                {
                        $left=0;
                        last;
                }
                $offset+=$lmerDistance; 
        }

        ###
        $offset=0;
        while($offset<$linkerLen-$lmerLen) 
        { 
                if($seq2=~/^(.+?)$lmers{$offset}/i)
                {
                        ($right,$rightOffset)=(length($1),$offset) if(!defined($right) or $right>length($1)) ;

                }
                elsif($seq2=~/^$lmers{$offset}/i)
                {
                        $right=0;
                        last;
                }
                $offset+=$lmerDistance; 
        }

        if($left and $right and $left>=20 and $right>=20 and $seqLen-$left-$right<20)
        {
                undef($left);
                undef($right);
        }

        if($left and $right)
        {
                $left -=$leftOffset;
                $left=0  if($left<0);

                $right -=$rightOffset;
                $right=0  if($right<0);
        }

        if($left and $right) # linker in the middle
        {       
                $revSeq=substr($seq,-$right);
                $fwdSeq=revComp(substr($seq,0,$left));
                $linkerSeq=substr($seq,$left,$seqLen-$left-$right);
        }
        elsif($left)
        {
                $fwdSeq=substr($seq,0,$left);
                $linkerSeq=substr($seq,$left);
        }
        elsif($right)
        {
                $fwdSeq=substr($seq,-$right);
                $linkerSeq=substr($seq,0,$seqLen-$right);
        }
        elsif(!defined($left))
        {
                $fwdSeq=$seq;
                $linkerSeq="";
        }
        else
        {
                $linkerSeq=$seq;
        }

        return ($fwdSeq,$revSeq,$linkerSeq);
}


sub revComp
{
        my ($seq)=@_;
        $seq=reverse $seq;   
        $seq=~tr/acgtACGT/tgcaTGCA/;
        return $seq;
}

